# Kotlinで記述するデザインパターンの学習

* Iterator
* Adapter: 
     * すでに提供されているものを利用可能な状態にする
     * 拡張機能(例：既存APIver1 + 新規APIver2)として実装したい箇所に集中する
* Template Method:
    1. 抽象クラスで抽象メソッドとそのメソッドを用いたテンプレートメソッドを定義する。
    1. 具象クラスで実装する
    1. 具象クラスを呼び出し、抽象クラスの型に代入してメソッドを呼び出す(変更があった際は抽象クラスのメソッドを修正させるため)
    * サブクラスでアルゴリズムを記述する手間がかからない
    * 処理に順序が存在する場合に特に威力を発揮する
    * 処理の実装を伴うため、インターフェースではなく抽象クラスを用いる
* Factory Method:
    * インスタンス生成の枠組み（フレームワーク）を決めるパターン
    1. インスタンスを生成するFactory、Factoryから生成されるインスタンスProductをフレームワークパッケージとして用意（両者は抽象クラス）
    1. 具体的なProduct生成クラスと具滝的なProductを用意する
    * 利用者はProductがどのような手順でインスタンスが生成されているかを知らずにすむ
    * newによるインスタンス生成をメソッド呼び出しに変えることで、具体的なクラス名による束縛からスーパークラスを解放している。
    * 具体的な実装がフレームワークのパッケージに依存しないため、フレームワークは使い回しがきく
* Singleton:
    * インスタンスの生成を1つにする
    * このパターンを持ちるべきかどうか議論があるので保留
* Prototype:
    * 雛形クラスをnewすることなく、そのインスタンスを複製するパターン
    * 種類ごとにクラスを作成する必要がなくなる
    * 図形を表すインスタンスなど、インスタンス生成が難しい場合にも用いる
    * インスタンス複製を行う部分をframeworkのパッケージに配置し、複製メソッドにインスタンス生成のための名前を指定することでクラス名に依存しなくなる
    
